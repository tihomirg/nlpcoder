Short form read (SFR):

1) var
2) var.method
3) var.field
4) var[]
5) op ...
6) ... op
7) ... op ...
8) ClassName.method
9) ClassName.field
10) new T
11) literal
12) hole
13) (type) ...

Sort form write (SFW):

1) var = SFR
2) var.field = SFR
3) var[] = SFR

SF = SFR \cup SFW
SFLE = {var, var.field, var[]}



Long form read (LFR):

1) var
2) var.method(SF*)
3) var.field
4) var[SF]
5) op SFLE
6) SFLE op
7) SF op SF
8) ClassName.method(SF*)
9) ClassName.field
10) new T(SF*)
11) literal
12) hole
13) (type) SF

Long for write (LFW):

1) var = LF
2) var.field = LF
3) var[SF] = LF

LF = LFR \cup LFW


Example:

(i = bis.read()) != -1

I check if it is in "Variable Normal Form".
II type inference (if possible) do some simple. Only when we are 100% sure. For now without it.

1) store: !=       read(!=, {int seq} = {bis seq} .read, literal)
2) store: i        read(=, _, {bis seq}.read)
3) store: bis      read(_.read)

(a1.f1 + a2.f2) != -1

1) store: !=       read(!=, +[int], literal[int])
2) Emit  literal(!=, 2, -1)
3) store: +        read(+, a1.f1, a2.f2)


Saving literals:
literal(declaration, #arg, value)

declarations = [static] methods, [static] fields, operators
