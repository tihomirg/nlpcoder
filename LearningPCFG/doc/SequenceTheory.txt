----------------------------------------------- Instructions --------------------------------------------

Short form read (SFR):

1) var
2) var.method
3) var.field
4) var[]
5) op ...
6) ... op
7) ... op ...
8) ClassName.method
9) ClassName.field
10) new T
11) literal
12) hole
13) (type) ...

Sort form write (SFW):

1) var = SFR
2) var.field = SFR
3) var[] = SFR

SF = SFR \cup SFW
SFLE = {var, var.field, var[]}



Long form read (LFR):

1) var
2) var.method(SF*)
3) var.field
4) var[SF]
5) op SFLE
6) SFLE op
7) SF op SF
8) ClassName.method(SF*)
9) ClassName.field
10) new T(SF*)
11) literal
12) hole
13) (type) SF

Long form write (LFW):

1) var = LFR
2) var.field = LFR
3) var[SF] = LFR

LF = LFR \cup LFW

Example:

(i = bis.read()) != -1

I check if it is in "Variable Normal Form".
II type inference (if possible) do some simple. Only when we are 100% sure. For now without it.

1) store: !=       read(!=, {int seq} = {bis seq} .read, literal)
2) store: i        read(=, _, {bis seq}.read)
3) store: bis      read(_.read)

(a1.f1 + a2.f2) != -1

1) store: !=       read(!=, +[int], literal[int])
2) Emit literal(!=, 2, -1)
3) store: +        read(+, a1.f1, a2.f2)


Saving literals:
literal(declaration, #arg, value)

declarations = [static] methods, [static] fields, operators


-------------------------------------------------- Conditions -------------------------------------------

We save them, but rename variables to normalize the term. 
We also produce a set of substitutions. For each variable
in the condition we add the condition to the sequence.

For instance:

int a;
int b;
if(a.read(b)) 

Produces var1.read(var2) substitution var1 -> a and var2 -> b.
This further produces two instructions:

For a:
if-cond (var1.read(var2)), [var1 -> _, var2 -> {seq int}]

For b:
if-cond (var1.read(var2)), [var1 -> {seq int}, var2 -> _]


For the variable that are not mentioned in the condition we put "?" everything is satisfiable.

In the future we may want to put the conditions into variable normal form.

-------------------------------------------------- 



We need to keep info about the read as top or argument.


-------------------------------------------------- Location -------------------------------------------------

Should we save the entire location for each variable, or keep everithing in the
for of AST. I'm more for the second solution.
We start recording variables 


------------------------------------------------- Constructs ------------------------------------------------


--------------------------------------------- Why such sequences? -------------------------------------------
This should also appear in the evaluation section.

After initial examination we decide to go with such a model. We can build such a model because it involves
API only and the connection among different "API" objects. The exceptions are static declarations and literals.
However, they appear so often in the code that we can not neglect them. We treat them as separate elements,
and save the important data, i.e., with what methods they appear often.

Q: How many new sequences do we 

------------------------------------------- Sequence Holes as Types ------------------------------------------
All "read" conditions can be encoded as constant types. We will create selection structure for the sequences 
based on those types. Also, conditions can be encoded in the same way.

Think how to encode location. (depends on the way we save it.)

------------------------------------------- Saving parameter sequences ---------------------------------------

Parameter sequences can be used to connect local variables. Another way to connect local variables is to extract
their sequences, use them as key and find the complete sequences. This is orthogonal, but important.


